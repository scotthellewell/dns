package api

import (
	"encoding/json"
	"io"
	"net/http"
	"time"

	"github.com/scott/dns/certs"
)

// CertManagerInterface defines the interface for certificate managers
// Both certs.Manager and certs.SNIManager implement this
type CertManagerInterface interface {
	GetConfig() certs.Config
	GetCertificatePEM() ([]byte, error)
	UploadCertificate(certPEM, keyPEM []byte) error
	IsExpired() bool
	IsExpiringSoon(within time.Duration) bool
}

// certManager holds reference to the certificate manager
var certManager CertManagerInterface

// acmeManager holds reference to the ACME manager
var acmeManager *certs.ACMEManager

// SetCertManager sets the certificate manager for API handlers
func SetCertManager(cm CertManagerInterface) {
	certManager = cm
}

// SetACMEManager sets the ACME manager for API handlers
func SetACMEManager(am *certs.ACMEManager) {
	acmeManager = am
}

// RegisterCertRoutes registers certificate management API routes
func RegisterCertRoutes(mux *http.ServeMux, corsMiddleware func(http.HandlerFunc) http.HandlerFunc) {
	mux.HandleFunc("/api/certs", corsMiddleware(handleCerts))
	mux.HandleFunc("/api/certs/generate", corsMiddleware(handleCertsGenerate))
	mux.HandleFunc("/api/certs/upload", corsMiddleware(handleCertsUpload))
	mux.HandleFunc("/api/certs/acme", corsMiddleware(handleACME))
	mux.HandleFunc("/api/certs/acme/request", corsMiddleware(handleACMERequest))
	mux.HandleFunc("/api/certs/acme/renew", corsMiddleware(handleACMERenew))
}

// RegisterCertRoutesWithAuth registers certificate routes with auth
func RegisterCertRoutesWithAuth(mux *http.ServeMux, corsMiddleware func(http.HandlerFunc) http.HandlerFunc, authMiddleware func(http.HandlerFunc) http.HandlerFunc) {
	wrap := func(h http.HandlerFunc) http.HandlerFunc {
		return corsMiddleware(authMiddleware(h))
	}
	mux.HandleFunc("/api/certs", wrap(handleCerts))
	mux.HandleFunc("/api/certs/generate", wrap(handleCertsGenerate))
	mux.HandleFunc("/api/certs/upload", wrap(handleCertsUpload))
	mux.HandleFunc("/api/certs/acme", wrap(handleACME))
	mux.HandleFunc("/api/certs/acme/request", wrap(handleACMERequest))
	mux.HandleFunc("/api/certs/acme/renew", wrap(handleACMERenew))
}

// CertInfoResponse contains certificate information
type CertInfoResponse struct {
	AutoGenerated bool     `json:"auto_generated"`
	Subject       string   `json:"subject"`
	Issuer        string   `json:"issuer"`
	NotBefore     string   `json:"not_before"`
	NotAfter      string   `json:"not_after"`
	DNSNames      []string `json:"dns_names"`
	IPAddresses   []string `json:"ip_addresses"`
	IsExpired     bool     `json:"is_expired"`
	IsExpiringSoon bool    `json:"is_expiring_soon"` // within 30 days
}

// handleCerts handles GET /api/certs - returns certificate info
func handleCerts(w http.ResponseWriter, r *http.Request) {
	if certManager == nil {
		http.Error(w, "Certificate manager not initialized", http.StatusServiceUnavailable)
		return
	}

	switch r.Method {
	case http.MethodGet:
		config := certManager.GetConfig()
		
		resp := CertInfoResponse{
			AutoGenerated:  config.AutoGenerated,
			Subject:        config.Subject,
			Issuer:         config.Issuer,
			NotBefore:      config.NotBefore.Format("2006-01-02T15:04:05Z"),
			NotAfter:       config.NotAfter.Format("2006-01-02T15:04:05Z"),
			DNSNames:       config.DNSNames,
			IPAddresses:    config.IPAddresses,
			IsExpired:      certManager.IsExpired(),
			IsExpiringSoon: certManager.IsExpiringSoon(30 * 24 * time.Hour), // 30 days
		}
		
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(resp)

	case http.MethodOptions:
		w.WriteHeader(http.StatusOK)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// SelfSignedGenerator is an optional interface for managers that support self-signed cert generation
type SelfSignedGenerator interface {
	GenerateSelfSigned(commonName string, dnsNames []string, ipAddresses []string) error
}

// GenerateCertRequest contains parameters for generating a self-signed certificate
type GenerateCertRequest struct {
	CommonName  string   `json:"common_name"`
	DNSNames    []string `json:"dns_names"`
	IPAddresses []string `json:"ip_addresses"`
}

// handleCertsGenerate handles POST /api/certs/generate
func handleCertsGenerate(w http.ResponseWriter, r *http.Request) {
	if certManager == nil {
		http.Error(w, "Certificate manager not initialized", http.StatusServiceUnavailable)
		return
	}

	generator, ok := certManager.(SelfSignedGenerator)
	if !ok {
		http.Error(w, "Self-signed certificate generation not supported with SNI manager. Use ACME or upload a certificate.", http.StatusNotImplemented)
		return
	}

	switch r.Method {
	case http.MethodPost:
		var req GenerateCertRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid JSON: "+err.Error(), http.StatusBadRequest)
			return
		}

		// Defaults
		if req.CommonName == "" {
			req.CommonName = "localhost"
		}
		if len(req.DNSNames) == 0 {
			req.DNSNames = []string{"localhost"}
		}
		if len(req.IPAddresses) == 0 {
			req.IPAddresses = []string{"127.0.0.1", "::1"}
		}

		if err := generator.GenerateSelfSigned(req.CommonName, req.DNSNames, req.IPAddresses); err != nil {
			http.Error(w, "Failed to generate certificate: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": true,
			"message": "Self-signed certificate generated successfully",
		})

	case http.MethodOptions:
		w.WriteHeader(http.StatusOK)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// UploadCertRequest contains the certificate and key to upload
type UploadCertRequest struct {
	Certificate string `json:"certificate"` // PEM-encoded certificate
	PrivateKey  string `json:"private_key"` // PEM-encoded private key
}

// handleCertsUpload handles POST /api/certs/upload
func handleCertsUpload(w http.ResponseWriter, r *http.Request) {
	if certManager == nil {
		http.Error(w, "Certificate manager not initialized", http.StatusServiceUnavailable)
		return
	}

	switch r.Method {
	case http.MethodPost:
		// Check content type
		contentType := r.Header.Get("Content-Type")
		
		var certPEM, keyPEM []byte
		
		if contentType == "multipart/form-data" || 
			len(contentType) > 19 && contentType[:19] == "multipart/form-data" {
			// Handle file upload
			if err := r.ParseMultipartForm(10 << 20); err != nil { // 10MB max
				http.Error(w, "Failed to parse form: "+err.Error(), http.StatusBadRequest)
				return
			}
			
			certFile, _, err := r.FormFile("certificate")
			if err != nil {
				http.Error(w, "Missing certificate file: "+err.Error(), http.StatusBadRequest)
				return
			}
			defer certFile.Close()
			certPEM, err = io.ReadAll(certFile)
			if err != nil {
				http.Error(w, "Failed to read certificate: "+err.Error(), http.StatusBadRequest)
				return
			}
			
			keyFile, _, err := r.FormFile("private_key")
			if err != nil {
				http.Error(w, "Missing private key file: "+err.Error(), http.StatusBadRequest)
				return
			}
			defer keyFile.Close()
			keyPEM, err = io.ReadAll(keyFile)
			if err != nil {
				http.Error(w, "Failed to read private key: "+err.Error(), http.StatusBadRequest)
				return
			}
		} else {
			// Handle JSON upload
			var req UploadCertRequest
			if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
				http.Error(w, "Invalid JSON: "+err.Error(), http.StatusBadRequest)
				return
			}
			certPEM = []byte(req.Certificate)
			keyPEM = []byte(req.PrivateKey)
		}

		if err := certManager.UploadCertificate(certPEM, keyPEM); err != nil {
			http.Error(w, "Failed to upload certificate: "+err.Error(), http.StatusBadRequest)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": true,
			"message": "Certificate uploaded successfully",
		})

	case http.MethodOptions:
		w.WriteHeader(http.StatusOK)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// ACMEConfigResponse contains ACME configuration and state
type ACMEConfigResponse struct {
	Enabled       bool     `json:"enabled"`
	Email         string   `json:"email"`
	Domains       []string `json:"domains"`
	UseStaging    bool     `json:"use_staging"`
	ChallengeType string   `json:"challenge_type"`
	AutoRenew     bool     `json:"auto_renew"`
	RenewBefore   int      `json:"renew_before"`
	LastRenewal   string   `json:"last_renewal,omitempty"`
	NextRenewal   string   `json:"next_renewal,omitempty"`
}

// handleACME handles GET/PUT /api/certs/acme - get or update ACME configuration
func handleACME(w http.ResponseWriter, r *http.Request) {
	if acmeManager == nil {
		http.Error(w, "ACME manager not initialized", http.StatusServiceUnavailable)
		return
	}

	switch r.Method {
	case http.MethodGet:
		config := acmeManager.GetConfig()
		state := acmeManager.GetState()

		resp := ACMEConfigResponse{
			Enabled:       config.Enabled,
			Email:         config.Email,
			Domains:       config.Domains,
			UseStaging:    config.UseStaging,
			ChallengeType: config.ChallengeType,
			AutoRenew:     config.AutoRenew,
			RenewBefore:   config.RenewBefore,
		}

		if !state.LastRenewal.IsZero() {
			resp.LastRenewal = state.LastRenewal.Format(time.RFC3339)
		}
		if !state.NextRenewal.IsZero() {
			resp.NextRenewal = state.NextRenewal.Format(time.RFC3339)
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(resp)

	case http.MethodPut:
		var req certs.ACMEConfig
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid JSON: "+err.Error(), http.StatusBadRequest)
			return
		}

		if err := acmeManager.UpdateConfig(req); err != nil {
			http.Error(w, "Failed to update ACME config: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": true,
			"message": "ACME configuration updated",
		})

	case http.MethodOptions:
		w.WriteHeader(http.StatusOK)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// ACMERequestRequest contains parameters for requesting an ACME certificate
type ACMERequestRequest struct {
	Email   string   `json:"email"`
	Domains []string `json:"domains"`
}

// handleACMERequest handles POST /api/certs/acme/request - request a new certificate
func handleACMERequest(w http.ResponseWriter, r *http.Request) {
	if acmeManager == nil {
		http.Error(w, "ACME manager not initialized", http.StatusServiceUnavailable)
		return
	}

	switch r.Method {
	case http.MethodPost:
		var req ACMERequestRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid JSON: "+err.Error(), http.StatusBadRequest)
			return
		}

		if req.Email == "" {
			http.Error(w, "Email is required", http.StatusBadRequest)
			return
		}
		if len(req.Domains) == 0 {
			http.Error(w, "At least one domain is required", http.StatusBadRequest)
			return
		}

		if err := acmeManager.RequestCertificate(req.Email, req.Domains); err != nil {
			http.Error(w, "Failed to request certificate: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": true,
			"message": "Certificate obtained successfully",
		})

	case http.MethodOptions:
		w.WriteHeader(http.StatusOK)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// handleACMERenew handles POST /api/certs/acme/renew - renew the current certificate
func handleACMERenew(w http.ResponseWriter, r *http.Request) {
	if acmeManager == nil {
		http.Error(w, "ACME manager not initialized", http.StatusServiceUnavailable)
		return
	}

	switch r.Method {
	case http.MethodPost:
		if err := acmeManager.RenewCertificate(); err != nil {
			http.Error(w, "Failed to renew certificate: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": true,
			"message": "Certificate renewed successfully",
		})

	case http.MethodOptions:
		w.WriteHeader(http.StatusOK)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}
