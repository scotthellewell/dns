package certs

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"math/big"
	"net"
	"os"
	"sync"
	"time"
)

// Config holds certificate configuration and metadata
type Config struct {
	AutoGenerated bool      `json:"auto_generated"`
	Subject       string    `json:"subject"`
	Issuer        string    `json:"issuer"`
	NotBefore     time.Time `json:"not_before"`
	NotAfter      time.Time `json:"not_after"`
	DNSNames      []string  `json:"dns_names"`
	IPAddresses   []string  `json:"ip_addresses"`
}

// CertStorage defines storage methods needed by cert manager
type CertStorage interface {
	StoreCertificate(domain string, certPEM, keyPEM []byte, subject, issuer string, notBefore, notAfter time.Time, dnsNames, ipAddresses []string) error
}

// Manager handles TLS certificate storage and management
type Manager struct {
	mu         sync.RWMutex
	cert       *tls.Certificate
	config     Config
	certFile   string
	keyFile    string
	configFile string
	storage    CertStorage
}

// NewManager creates a new certificate manager
func NewManager() (*Manager, error) {
	m := &Manager{
		certFile:   "tls-cert.pem",
		keyFile:    "tls-key.pem",
		configFile: "tls-config.json",
	}

	// Try to load existing certificate
	if err := m.loadCertificate(); err != nil {
		// No existing certificate, generate a self-signed one
		if err := m.GenerateSelfSigned("localhost", []string{"localhost"}, []string{"127.0.0.1", "::1"}); err != nil {
			return nil, fmt.Errorf("failed to generate initial certificate: %v", err)
		}
	}

	return m, nil
}

// loadCertificate loads certificate from files
func (m *Manager) loadCertificate() error {
	// Load config
	configData, err := os.ReadFile(m.configFile)
	if err != nil {
		return fmt.Errorf("failed to read config: %v", err)
	}

	var config Config
	if err := json.Unmarshal(configData, &config); err != nil {
		return fmt.Errorf("failed to parse config: %v", err)
	}

	// Load certificate
	cert, err := tls.LoadX509KeyPair(m.certFile, m.keyFile)
	if err != nil {
		return fmt.Errorf("failed to load certificate: %v", err)
	}

	m.mu.Lock()
	m.cert = &cert
	m.config = config
	m.mu.Unlock()

	return nil
}

// saveConfig saves certificate metadata to file
func (m *Manager) saveConfig() error {
	data, err := json.MarshalIndent(m.config, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal config: %v", err)
	}

	return os.WriteFile(m.configFile, data, 0644)
}

// GenerateSelfSigned generates a new self-signed certificate
func (m *Manager) GenerateSelfSigned(commonName string, dnsNames []string, ipAddresses []string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Generate private key
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return fmt.Errorf("failed to generate private key: %v", err)
	}

	// Parse IP addresses
	var ips []net.IP
	for _, ipStr := range ipAddresses {
		if ip := net.ParseIP(ipStr); ip != nil {
			ips = append(ips, ip)
		}
	}

	// Generate serial number
	serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	if err != nil {
		return fmt.Errorf("failed to generate serial number: %v", err)
	}

	notBefore := time.Now()
	notAfter := notBefore.Add(365 * 24 * time.Hour) // 1 year validity

	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName:   commonName,
			Organization: []string{"DNS Server"},
		},
		NotBefore:             notBefore,
		NotAfter:              notAfter,
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
		DNSNames:              dnsNames,
		IPAddresses:           ips,
	}

	// Create certificate
	certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &privateKey.PublicKey, privateKey)
	if err != nil {
		return fmt.Errorf("failed to create certificate: %v", err)
	}

	// Encode certificate to PEM
	certPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certDER})

	// Encode private key to PEM
	keyDER, err := x509.MarshalECPrivateKey(privateKey)
	if err != nil {
		return fmt.Errorf("failed to marshal private key: %v", err)
	}
	keyPEM := pem.EncodeToMemory(&pem.Block{Type: "EC PRIVATE KEY", Bytes: keyDER})

	// Save files
	if err := os.WriteFile(m.certFile, certPEM, 0644); err != nil {
		return fmt.Errorf("failed to save certificate: %v", err)
	}
	if err := os.WriteFile(m.keyFile, keyPEM, 0600); err != nil {
		return fmt.Errorf("failed to save private key: %v", err)
	}

	// Load the certificate
	cert, err := tls.X509KeyPair(certPEM, keyPEM)
	if err != nil {
		return fmt.Errorf("failed to load certificate: %v", err)
	}

	// Update state
	m.cert = &cert
	m.config = Config{
		AutoGenerated: true,
		Subject:       commonName,
		Issuer:        commonName,
		NotBefore:     notBefore,
		NotAfter:      notAfter,
		DNSNames:      dnsNames,
		IPAddresses:   ipAddresses,
	}

	// Save config
	return m.saveConfig()
}

// UploadCertificate uploads a PEM-encoded certificate and key
func (m *Manager) UploadCertificate(certPEM, keyPEM []byte) error {
	// Validate the certificate and key
	cert, err := tls.X509KeyPair(certPEM, keyPEM)
	if err != nil {
		return fmt.Errorf("invalid certificate or key: %v", err)
	}

	// Parse certificate to extract metadata
	x509Cert, err := x509.ParseCertificate(cert.Certificate[0])
	if err != nil {
		return fmt.Errorf("failed to parse certificate: %v", err)
	}

	m.mu.Lock()
	defer m.mu.Unlock()

	// Extract IP addresses as strings
	var ipAddresses []string
	for _, ip := range x509Cert.IPAddresses {
		ipAddresses = append(ipAddresses, ip.String())
	}

	// Save to storage or files
	if m.storage != nil {
		if err := m.storage.StoreCertificate("default", certPEM, keyPEM, x509Cert.Subject.CommonName, x509Cert.Issuer.CommonName, x509Cert.NotBefore, x509Cert.NotAfter, x509Cert.DNSNames, ipAddresses); err != nil {
			return fmt.Errorf("failed to save certificate: %v", err)
		}
	} else if m.certFile != "" {
		// Save files
		if err := os.WriteFile(m.certFile, certPEM, 0644); err != nil {
			return fmt.Errorf("failed to save certificate: %v", err)
		}
		if err := os.WriteFile(m.keyFile, keyPEM, 0600); err != nil {
			return fmt.Errorf("failed to save private key: %v", err)
		}
		// Save config
		if err := m.saveConfig(); err != nil {
			return err
		}
	}

	// Update state
	m.cert = &cert
	m.config = Config{
		AutoGenerated: false,
		Subject:       x509Cert.Subject.CommonName,
		Issuer:        x509Cert.Issuer.CommonName,
		NotBefore:     x509Cert.NotBefore,
		NotAfter:      x509Cert.NotAfter,
		DNSNames:      x509Cert.DNSNames,
		IPAddresses:   ipAddresses,
	}

	return nil
}

// GetTLSConfig returns a TLS configuration using the current certificate
func (m *Manager) GetTLSConfig() (*tls.Config, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	if m.cert == nil {
		return nil, fmt.Errorf("no certificate configured")
	}

	return &tls.Config{
		Certificates: []tls.Certificate{*m.cert},
		MinVersion:   tls.VersionTLS12,
	}, nil
}

// GetConfig returns the current certificate configuration
func (m *Manager) GetConfig() Config {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.config
}

// GetCertificatePEM returns the current certificate in PEM format
func (m *Manager) GetCertificatePEM() ([]byte, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	data, err := os.ReadFile(m.certFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read certificate: %v", err)
	}
	return data, nil
}

// IsExpiringSoon returns true if the certificate expires within the given duration
func (m *Manager) IsExpiringSoon(within time.Duration) bool {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return time.Until(m.config.NotAfter) < within
}

// IsExpired returns true if the certificate has expired
func (m *Manager) IsExpired() bool {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return time.Now().After(m.config.NotAfter)
}
