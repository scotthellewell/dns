package certs

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"log"
	"math/big"
	"net"
	"time"

	"github.com/scott/dns/storage"
)

// StorageInterface defines storage methods needed by cert manager
type StorageInterface interface {
	GetCertificate(domain string) (*storage.TLSCertificate, error)
	StoreCertificate(cert *storage.TLSCertificate) error
	ListCertificates() ([]storage.TLSCertificate, error)
	GetACMEConfig() (*storage.ACMEConfig, error)
	UpdateACMEConfig(config *storage.ACMEConfig) error
	GetACMEAccountKey() ([]byte, error)
	SaveACMEAccountKey(key []byte) error
}

// certStorageAdapter adapts StorageInterface to CertStorage
type certStorageAdapter struct {
	store StorageInterface
}

func (a *certStorageAdapter) StoreCertificate(domain string, certPEM, keyPEM []byte, subject, issuer string, notBefore, notAfter time.Time, dnsNames, ipAddresses []string) error {
	return a.store.StoreCertificate(&storage.TLSCertificate{
		Domain:        domain,
		CertPEM:       string(certPEM),
		KeyPEM:        string(keyPEM),
		AutoGenerated: false,
		Subject:       subject,
		Issuer:        issuer,
		NotBefore:     notBefore,
		NotAfter:      notAfter,
		DNSNames:      dnsNames,
		IPAddresses:   ipAddresses,
	})
}

// NewManagerWithStorage creates a certificate manager backed by storage
func NewManagerWithStorage(store StorageInterface) *Manager {
	m := &Manager{
		// No file paths needed with storage
		certFile:   "",
		keyFile:    "",
		configFile: "",
		storage:    &certStorageAdapter{store: store},
	}

	// Try to load existing certificate from storage
	cert, err := store.GetCertificate("default")
	if err != nil || cert == nil {
		// No existing certificate, generate a self-signed one in-memory
		if err := generateSelfSignedInMemory(m, "localhost", []string{"localhost"}, []string{"127.0.0.1", "::1"}); err != nil {
			log.Printf("Warning: Failed to generate initial certificate: %v", err)
			return nil
		}
	} else {
		// Load from storage
		tlsCert, err := tls.X509KeyPair([]byte(cert.CertPEM), []byte(cert.KeyPEM))
		if err != nil {
			log.Printf("Warning: Failed to load certificate from storage: %v", err)
			return nil
		}
		m.cert = &tlsCert
		m.config = Config{
			AutoGenerated: cert.AutoGenerated,
			Subject:       cert.Subject,
			Issuer:        cert.Issuer,
			NotBefore:     cert.NotBefore,
			NotAfter:      cert.NotAfter,
			DNSNames:      cert.DNSNames,
			IPAddresses:   cert.IPAddresses,
		}
	}

	return m
}

// generateSelfSignedInMemory generates a self-signed certificate without saving to files
func generateSelfSignedInMemory(m *Manager, commonName string, dnsNames []string, ipAddresses []string) error {
	// Generate private key
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return err
	}

	// Parse IP addresses
	var ips []net.IP
	for _, ipStr := range ipAddresses {
		if ip := net.ParseIP(ipStr); ip != nil {
			ips = append(ips, ip)
		}
	}

	// Generate serial number
	serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	if err != nil {
		return err
	}

	notBefore := time.Now()
	notAfter := notBefore.Add(365 * 24 * time.Hour)

	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName:   commonName,
			Organization: []string{"DNS Server"},
		},
		NotBefore:             notBefore,
		NotAfter:              notAfter,
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
		DNSNames:              dnsNames,
		IPAddresses:           ips,
	}

	// Create certificate
	certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &privateKey.PublicKey, privateKey)
	if err != nil {
		return err
	}

	// Encode certificate to PEM
	certPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certDER})

	// Encode private key to PEM
	keyDER, err := x509.MarshalECPrivateKey(privateKey)
	if err != nil {
		return err
	}
	keyPEM := pem.EncodeToMemory(&pem.Block{Type: "EC PRIVATE KEY", Bytes: keyDER})

	// Load the certificate
	cert, err := tls.X509KeyPair(certPEM, keyPEM)
	if err != nil {
		return err
	}

	// Update state (no file saving)
	m.cert = &cert
	m.config = Config{
		AutoGenerated: true,
		Subject:       commonName,
		Issuer:        commonName,
		NotBefore:     notBefore,
		NotAfter:      notAfter,
		DNSNames:      dnsNames,
		IPAddresses:   ipAddresses,
	}

	return nil
}

// acmeStorageAdapter adapts StorageInterface to ACMEStorage
type acmeStorageAdapter struct {
	store StorageInterface
}

func (a *acmeStorageAdapter) GetACMEConfig() (*ACMEConfig, error) {
	cfg, err := a.store.GetACMEConfig()
	if err != nil {
		return nil, err
	}
	return &ACMEConfig{
		Enabled:       cfg.Enabled,
		Email:         cfg.Email,
		Domains:       cfg.Domains,
		UseStaging:    cfg.UseStaging,
		ChallengeType: cfg.ChallengeType,
		AutoRenew:     cfg.AutoRenew,
		RenewBefore:   cfg.RenewBefore,
	}, nil
}

func (a *acmeStorageAdapter) UpdateACMEConfig(config *ACMEConfig) error {
	return a.store.UpdateACMEConfig(&storage.ACMEConfig{
		Enabled:       config.Enabled,
		Email:         config.Email,
		Domains:       config.Domains,
		UseStaging:    config.UseStaging,
		ChallengeType: config.ChallengeType,
		AutoRenew:     config.AutoRenew,
		RenewBefore:   config.RenewBefore,
	})
}

func (a *acmeStorageAdapter) GetACMEAccountKey() ([]byte, error) {
	return a.store.GetACMEAccountKey()
}

func (a *acmeStorageAdapter) SaveACMEAccountKey(key []byte) error {
	return a.store.SaveACMEAccountKey(key)
}

// NewACMEManagerWithStorage creates an ACME manager backed by storage
func NewACMEManagerWithStorage(certMgr *Manager, store StorageInterface) (*ACMEManager, error) {
	// Load ACME config from storage
	acmeConfig, err := store.GetACMEConfig()
	if err != nil {
		// Use default config
		acmeConfig = &storage.ACMEConfig{
			Enabled:     false,
			AutoRenew:   true,
			RenewBefore: 30,
		}
	}

	a := &ACMEManager{
		certManager:    certMgr,
		configFile:     "", // Not used with storage
		stateFile:      "", // Not used with storage
		accountKeyFile: "",
		stopRenew:      make(chan struct{}),
		storage:        &acmeStorageAdapter{store: store},
		config: ACMEConfig{
			Enabled:       acmeConfig.Enabled,
			Email:         acmeConfig.Email,
			Domains:       acmeConfig.Domains,
			UseStaging:    acmeConfig.UseStaging,
			ChallengeType: acmeConfig.ChallengeType,
			AutoRenew:     acmeConfig.AutoRenew,
			RenewBefore:   acmeConfig.RenewBefore,
		},
	}

	if a.config.ChallengeType == "" {
		a.config.ChallengeType = "dns-01"
	}

	return a, nil
}
